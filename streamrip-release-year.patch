diff --git a/streamrip/client/deezer.py b/streamrip/client/deezer.py
index 54fa397..a210f7b 100644
--- a/streamrip/client/deezer.py
+++ b/streamrip/client/deezer.py
@@
 class DeezerClient(Client):
@@
     async def get_track(self, item_id: str) -> dict:
         try:
             item = await asyncio.to_thread(self.client.api.get_track, item_id)
         except Exception as e:
             raise NonStreamableError(e)
@@
         try:
             album_metadata, album_tracks = await asyncio.gather(
                 asyncio.to_thread(self.client.api.get_album, album_id),
                 asyncio.to_thread(self.client.api.get_album_tracks, album_id),
             )
         except Exception as e:
             logger.error(f"Error fetching album of track {item_id}: {e}")
             return item
 
         album_metadata["tracks"] = album_tracks["data"]
         album_metadata["track_total"] = len(album_tracks["data"])
+        self._normalize_release_fields(
+            album_metadata, track=item, tracks=album_tracks.get("data")
+        )
         item["album"] = album_metadata
 
         return item
 
     async def get_album(self, item_id: str) -> dict:
         album_metadata, album_tracks = await asyncio.gather(
             asyncio.to_thread(self.client.api.get_album, item_id),
             asyncio.to_thread(self.client.api.get_album_tracks, item_id),
         )
         album_metadata["tracks"] = album_tracks["data"]
         album_metadata["track_total"] = len(album_tracks["data"])
+        self._normalize_release_fields(
+            album_metadata, tracks=album_tracks.get("data")
+        )
         return album_metadata
@@
     def _get_encrypted_file_url(
         self,
         meta_id: str,
         track_hash: str,
         media_version: str,
     ):
@@
         url = f"https://e-cdns-proxy-{track_hash[0]}.dzcdn.net/mobile/1/{path}"
         logger.debug("Encrypted file path %s", url)
         return url
+
+    @staticmethod
+    def _normalize_release_fields(
+        album_metadata: dict, track: dict | None = None, tracks: list[dict] | None = None
+    ) -> None:
+        """Fill in release_date/release_year when Deezer omits them.
+
+        Some deezer endpoints return album payloads without a release_date. That leaves
+        downstream metadata without a usable year, which prevents the tagger from
+        writing a release year. Pull the date from any available source so tags stay
+        populated.
+        """
+
+        def _first_release(items: list[dict]) -> str | None:
+            for candidate in items:
+                for key in ("release_date", "digital_release_date", "releaseYear", "release_year"):
+                    value = candidate.get(key)
+                    if value:
+                        return str(value)
+            return None
+
+        release_date = (
+            album_metadata.get("release_date")
+            or album_metadata.get("release_date_original")
+            or album_metadata.get("digital_release_date")
+        )
+        if not release_date and track:
+            release_date = track.get("release_date") or track.get("digital_release_date")
+        if not release_date and tracks:
+            release_date = _first_release(tracks)
+
+        if release_date:
+            album_metadata["release_date"] = release_date
+            album_metadata.setdefault("release_date_original", release_date)
+            album_metadata.setdefault("release_year", str(release_date)[:4])
diff --git a/streamrip/metadata/album.py b/streamrip/metadata/album.py
index 8bc4567..c1390ef 100644
--- a/streamrip/metadata/album.py
+++ b/streamrip/metadata/album.py
@@
     def from_deezer(cls, resp: dict) -> AlbumMetadata | None:
         album = resp.get("title", "Unknown Album")
         tracktotal = typed(resp.get("track_total", 0) or resp.get("nb_tracks", 0), int)
         disctotal = typed(resp["tracks"][-1]["disk_number"], int)
         genres = [typed(g["name"], str) for g in resp["genres"]["data"]]
 
-        date = typed(resp["release_date"], str)
-        year = date[:4]
+        date_raw = (
+            resp.get("release_date")
+            or resp.get("release_date_original")
+            or resp.get("digital_release_date")
+            or resp.get("release_year")
+        )
+        date = typed(str(date_raw), str) if date_raw is not None else "Unknown"
+        year = date[:4] if date_raw is not None else "Unknown"
         _copyright = None
         description = None
         albumartist = typed(safe_get(resp, "artist", "name"), str)
         albumcomposer = None
         label = resp.get("label")
@@
     def from_incomplete_deezer_track_resp(cls, resp: dict) -> AlbumMetadata | None:
         album_resp = resp["album"]
         album_id = album_resp["id"]
         album = album_resp["title"]
         covers = Covers.from_deezer(album_resp)
-        date = album_resp["release_date"]
-        year = date[:4]
+        date_raw = (
+            album_resp.get("release_date")
+            or album_resp.get("release_date_original")
+            or album_resp.get("digital_release_date")
+            or resp.get("release_date")
+            or resp.get("digital_release_date")
+            or resp.get("release_year")
+        )
+        date = str(date_raw) if date_raw is not None else "Unknown"
+        year = date[:4] if date_raw is not None else "Unknown"
         albumartist = ", ".join(a["name"] for a in resp["contributors"])
         explicit = resp.get("explicit_lyrics", False)
 
         info = AlbumInfo(
             id=album_id,
